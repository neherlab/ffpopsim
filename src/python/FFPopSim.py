# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


"""
C++/Python library for population genetics.

This library offers *two* simulation packages for population genetics: one for
low-dimensional simulations (up to ~15 loci) and one for high-dimensional ones.

Each package is based on a big class that represents a population:

   - ``haploid_lowd`` for low-dimensional populations
   - ``haploid_highd`` for high-dimensional simulations

A simple example routine is the following::

    #####################################
    #   EXAMPLE SCRIPT                  #
    #####################################
    import numpy as np
    import matplotlib.pyplot as plt
    import FFPopSim as h
    
    c = h.haploid_lowd(4)
    c.set_allele_frequencies([0,0.3,0.6,0.9], N=1000) 
    c.evolve(100)
    c.plot_diversity_histogram()
    plt.show()
    #####################################

which evolves a population with 4 loci for 100 generations starting from fixed
allele frequencies, under neutral conditions, and plots the diversity
histogram afterwards.

For more usage examples, please consult the ``tests`` and ``examples`` folders. 

"""


from sys import version_info
if version_info >= (3,0,0):
    new_instancemethod = lambda func, inst, cls: _FFPopSim.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_FFPopSim', [dirname(__file__)])
        except ImportError:
            import _FFPopSim
            return _FFPopSim
        if fp is not None:
            try:
                _mod = imp.load_module('_FFPopSim', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _FFPopSim = swig_import_helper()
    del swig_import_helper
else:
    import _FFPopSim
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


FREE_RECOMBINATION = _FFPopSim.FREE_RECOMBINATION
CROSSOVERS = _FFPopSim.CROSSOVERS
SINGLE_CROSSOVER = _FFPopSim.SINGLE_CROSSOVER
class index_value_pair(object):
    """Pair of an index and a value"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    index = _swig_property(_FFPopSim.index_value_pair_index_get, _FFPopSim.index_value_pair_index_set)
    val = _swig_property(_FFPopSim.index_value_pair_val_get, _FFPopSim.index_value_pair_val_set)
    def __init__(self, index_in=0, val_in=0): 
        """Pair of an index and a value"""
        _FFPopSim.index_value_pair_swiginit(self,_FFPopSim.new_index_value_pair(index_in, val_in))
    def __str__(self):
        """__str__(index_value_pair self) -> char const *"""
        return _FFPopSim.index_value_pair___str__(self)

    def __repr__(self):
        """__repr__(index_value_pair self) -> char const *"""
        return _FFPopSim.index_value_pair___repr__(self)

    __swig_destroy__ = _FFPopSim.delete_index_value_pair
index_value_pair.__str__ = new_instancemethod(_FFPopSim.index_value_pair___str__,None,index_value_pair)
index_value_pair.__repr__ = new_instancemethod(_FFPopSim.index_value_pair___repr__,None,index_value_pair)
index_value_pair_swigregister = _FFPopSim.index_value_pair_swigregister
index_value_pair_swigregister(index_value_pair)

class genotype_value_pair(object):
    """Pair of a genotype and a value"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    val = _swig_property(_FFPopSim.genotype_value_pair_val_get, _FFPopSim.genotype_value_pair_val_set)
    def __init__(self, *args, **kwargs): 
        """Pair of a genotype and a value"""
        _FFPopSim.genotype_value_pair_swiginit(self,_FFPopSim.new_genotype_value_pair(*args, **kwargs))
    def __str__(self):
        """__str__(genotype_value_pair self) -> char const *"""
        return _FFPopSim.genotype_value_pair___str__(self)

    def __repr__(self):
        """__repr__(genotype_value_pair self) -> char const *"""
        return _FFPopSim.genotype_value_pair___repr__(self)

    def _get_genotype_length(self):
        """_get_genotype_length(genotype_value_pair self) -> int"""
        return _FFPopSim.genotype_value_pair__get_genotype_length(self)

    def _get_genotype(self, *args, **kwargs):
        """_get_genotype(genotype_value_pair self, int DIM1)"""
        return _FFPopSim.genotype_value_pair__get_genotype(self, *args, **kwargs)

    def _set_genotype(self, *args, **kwargs):
        """_set_genotype(genotype_value_pair self, boost::dynamic_bitset< > genotype_in)"""
        return _FFPopSim.genotype_value_pair__set_genotype(self, *args, **kwargs)

    @property
    def genotype(self):
        '''Genotype'''
        import numpy as np
        return np.array(self._get_genotype(self._get_genotype_length()), bool)


    @genotype.setter
    def genotype(self, genotype):
        self._set_genotype(genotype)

    __swig_destroy__ = _FFPopSim.delete_genotype_value_pair
genotype_value_pair.__str__ = new_instancemethod(_FFPopSim.genotype_value_pair___str__,None,genotype_value_pair)
genotype_value_pair.__repr__ = new_instancemethod(_FFPopSim.genotype_value_pair___repr__,None,genotype_value_pair)
genotype_value_pair._get_genotype_length = new_instancemethod(_FFPopSim.genotype_value_pair__get_genotype_length,None,genotype_value_pair)
genotype_value_pair._get_genotype = new_instancemethod(_FFPopSim.genotype_value_pair__get_genotype,None,genotype_value_pair)
genotype_value_pair._set_genotype = new_instancemethod(_FFPopSim.genotype_value_pair__set_genotype,None,genotype_value_pair)
genotype_value_pair_swigregister = _FFPopSim.genotype_value_pair_swigregister
genotype_value_pair_swigregister(genotype_value_pair)

class stat(object):
    """Mean and variance of a statistical distribution"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    mean = _swig_property(_FFPopSim.stat_mean_get, _FFPopSim.stat_mean_set)
    variance = _swig_property(_FFPopSim.stat_variance_get, _FFPopSim.stat_variance_set)
    def __init__(self, mean_in=0, variance_in=0): 
        """Mean and variance of a statistical distribution"""
        _FFPopSim.stat_swiginit(self,_FFPopSim.new_stat(mean_in, variance_in))
    def __str__(self):
        """__str__(stat self) -> char const *"""
        return _FFPopSim.stat___str__(self)

    def __repr__(self):
        """__repr__(stat self) -> char const *"""
        return _FFPopSim.stat___repr__(self)

    __swig_destroy__ = _FFPopSim.delete_stat
stat.__str__ = new_instancemethod(_FFPopSim.stat___str__,None,stat)
stat.__repr__ = new_instancemethod(_FFPopSim.stat___repr__,None,stat)
stat_swigregister = _FFPopSim.stat_swigregister
stat_swigregister(stat)

def binarify(gt, L=0):
    '''Transform an integer into a binary sequence on the L hypercube.

    Parameters:
       - gt: integer representing a genotype
       - L: number of dimensions of the hypercube

    Returns:
       - genotype: bool vector representing the same genotype

    **Examples**:

    .. sourcecode:: ipython

       In [1]: binarify(3, 5)
       Out[1]: array([False, False, False,  True,  True], dtype=bool)

       In [2]: FFPopSim.binarify(0b11, 5)
       Out[2]: array([False, False, False,  True,  True], dtype=bool)       
    '''
    import numpy as np
    if not L:
        L=1
        while gt > ((1<<L) - 1):
            L += 1
    return np.array(map(lambda l: bool(gt&(1<<(L-l-1))),range(L)))


def integerify(b):
    '''Transform a binary sequence on the HC into an integer.

    Parameters:
       - b: bool vector representing a genotype

    Returns:
       - gt: integer representing the same genotype

    **Examples**:

    .. sourcecode:: ipython

       In [1]: integerify([False, True, True])
       Out[1]: 3
    '''
    import numpy as np
    L = len(b)
    a = [(1<<(L-l-1)) for l in xrange(L)]
    return np.dot(b,a)

HC_MEMERR = _FFPopSim.HC_MEMERR
HC_BADARG = _FFPopSim.HC_BADARG
HC_VERBOSE = _FFPopSim.HC_VERBOSE
HC_FUNC = _FFPopSim.HC_FUNC
HC_COEFF = _FFPopSim.HC_COEFF
HC_FUNC_EQ_COEFF = _FFPopSim.HC_FUNC_EQ_COEFF
HG_VERBOSE = _FFPopSim.HG_VERBOSE
HG_LONGTIMEGEN = _FFPopSim.HG_LONGTIMEGEN
HG_CONTINUOUS = _FFPopSim.HG_CONTINUOUS
HG_NOTHING = _FFPopSim.HG_NOTHING
HG_EXTINCT = _FFPopSim.HG_EXTINCT
HG_BADARG = _FFPopSim.HG_BADARG
HG_MEMERR = _FFPopSim.HG_MEMERR
class haploid_lowd(object):
    """
    Class for low-dimensional population genetics (short genomes ~20 loci).

    The class offers a number of functions, but an example will explain the basic idea::

        #####################################
        #   EXAMPLE SCRIPT                  #
        #####################################
        import numpy as np
        import matplotlib.pyplot as plt
        import FFPopSim as h
        
        c = h.haploid_lowd(5)               # 5 loci

        # initialize with 300 individuals with genotype 00000,
        # and 700 with genotype 00010
        c.set_genotypes([0, 2], [300, 700])
     
        # set an additive fitness landscape with these coefficients
        c.set_fitness_additive([0.02,0.03,0.04,0.02, -0.03])
        # Note: we are in the -/+ basis, so
        #        F[10000] - F[00000] = 2 * 0.02 
        # Hence the coefficients are half of the effect of mutation on fitness 

        c.evolve(100)                       # evolve for 100 generations
        c.plot_diversity_histogram()
        plt.show()
        #####################################

    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, L=1, rng_seed=0): 
        """
        Construct a low-dimensional population with certain parameters.

        Parameters:
            - L : number of loci (at least 1)
            - rng_seed : seed for the random number generator    

        """
        _FFPopSim.haploid_lowd_swiginit(self,_FFPopSim.new_haploid_lowd(L, rng_seed))
    __swig_destroy__ = _FFPopSim.delete_haploid_lowd
    carrying_capacity = _swig_property(_FFPopSim.haploid_lowd_carrying_capacity_get, _FFPopSim.haploid_lowd_carrying_capacity_set)
    outcrossing_rate = _swig_property(_FFPopSim.haploid_lowd_outcrossing_rate_get, _FFPopSim.haploid_lowd_outcrossing_rate_set)
    recombination_model = _swig_property(_FFPopSim.haploid_lowd_recombination_model_get, _FFPopSim.haploid_lowd_recombination_model_set)
    circular = _swig_property(_FFPopSim.haploid_lowd_circular_get, _FFPopSim.haploid_lowd_circular_set)
    def _get_number_of_loci(self):
        """number of loci (read-only)"""
        return _FFPopSim.haploid_lowd__get_number_of_loci(self)

    def _get_population_size(self):
        """population size (read-only)"""
        return _FFPopSim.haploid_lowd__get_population_size(self)

    def _get_generation(self):
        """current generation (read-only)"""
        return _FFPopSim.haploid_lowd__get_generation(self)

    def _get_mutation_rate(self, *args, **kwargs):
        """_get_mutation_rate(haploid_lowd self, int locus, int direction) -> double"""
        return _FFPopSim.haploid_lowd__get_mutation_rate(self, *args, **kwargs)

    def set_wildtype(self, *args, **kwargs):
        """set_wildtype(haploid_lowd self, unsigned long N) -> int"""
        return _FFPopSim.haploid_lowd_set_wildtype(self, *args, **kwargs)

    def _set_recombination_rates(self, *args, **kwargs):
        """_set_recombination_rates(haploid_lowd self, double * rec_rates, int rec_model=2) -> int"""
        return _FFPopSim.haploid_lowd__set_recombination_rates(self, *args, **kwargs)

    def evolve(self, gen=1):
        """
        Evolve for some generations

        Parameters:
            - gen: number of generations to evolve the population, defaults to one

        """
        return _FFPopSim.haploid_lowd_evolve(self, gen)

    def evolve_norec(self, gen=1):
        """
        Evolve for some generations without recombination

        Parameters:
            - gen: number of generations to evolve the population

        """
        return _FFPopSim.haploid_lowd_evolve_norec(self, gen)

    def evolve_deterministic(self, gen=1):
        """
        Evolve for some generations deterministically (skips the resampling)

        Parameters:
            - gen: number of generations to evolve the population

        """
        return _FFPopSim.haploid_lowd_evolve_deterministic(self, gen)

    def get_genotype_frequency(self, *args, **kwargs):
        """
        Get the frequency of a genotype

        Parameters:
            - gt: genotype, whose the frequency is to be returned

        Returns:
            - the frequency of the genotype

        """
        return _FFPopSim.haploid_lowd_get_genotype_frequency(self, *args, **kwargs)

    def get_allele_frequency(self, *args, **kwargs):
        """
        Get the frequency of the + allele

        Parameters:
            - locus: locus, at which the frequency of the + allele is to be computed

        Returns:
            - the frequency of the + allele, :math:`\nu_i := \frac{1 + \left<s_i\right>}{2}`, where :math:`s_i \in \{-1, 1\}`.

        """
        return _FFPopSim.haploid_lowd_get_allele_frequency(self, *args, **kwargs)

    def get_pair_frequency(self, *args, **kwargs):
        """
        Get the joint frequency of two + alleles

        Parameters:
            - locus1: first locus
            - locus2: second locus

        Returns:
            - the joint frequency of the + alleles

        """
        return _FFPopSim.haploid_lowd_get_pair_frequency(self, *args, **kwargs)

    def get_moment(self, *args, **kwargs):
        """
        Get moment of two alleles in the -/+ basis

        Parameters:
            - locus1: first locus
            - locus2: second locus

        Returns:
            - the second moment, i.e. :math:`\left<s_i s_j\right>`, where :math:`s_i, s_j \in \{-1, 1\}`.

        """
        return _FFPopSim.haploid_lowd_get_moment(self, *args, **kwargs)

    def get_LD(self, *args, **kwargs):
        """
        Get linkage disequilibrium

        Parameters:
            - locus1: first locus
            - locus2: second locus

        Returns:
            - the linkage disequilibiurm between them, i.e. :math:`LD := 1 / 4 \left<s_i s_j\right> - \chi_i \cdot \chi_j`.

        """
        return _FFPopSim.haploid_lowd_get_LD(self, *args, **kwargs)

    def get_chi(self, *args, **kwargs):
        """
        Get chi of an allele in the -/+ basis

        Parameters:
            - locus: locus whose chi is to be computed

        Returns:
            - the chi of that allele, :math:`\chi_i := \left<s_i\right>`, where :math:`s_i \in \{-1, 1\}`.

        """
        return _FFPopSim.haploid_lowd_get_chi(self, *args, **kwargs)

    def get_chi2(self, *args, **kwargs):
        """
        Get :math:`\chi_{ij}`

        Parameters:
            - locus1: first locus
            - locus2: second locus

        Returns:
            - the linkage disequilibiurm between them, i.e. :math:`\chi_{ij} := \left<s_i s_j\right> - \chi_i \cdot \chi_j`.

        """
        return _FFPopSim.haploid_lowd_get_chi2(self, *args, **kwargs)

    def genotype_entropy(self):
        """get the genotype entropy of the population: :math:`-\sum_{i=0}^{2^L} p_i\log p_i` """
        return _FFPopSim.haploid_lowd_genotype_entropy(self)

    def allele_entropy(self):
        """
        get the allele entropy of the population :math:`-\sum_{i=0}^{L} 
        u_i\log 
        u_i + (1-
        u_i)\log(1-
        u_i)` 
        """
        return _FFPopSim.haploid_lowd_allele_entropy(self)

    def get_fitness(self, *args, **kwargs):
        """
        Get fitness values of a genotype

        Parameters:
            - gt: genotype whose fitness is to be calculated. This can either be an integer or in binary format, e.g. 5 = 0b101 

        Returns:
            - the fitness of that genotype.

        """
        return _FFPopSim.haploid_lowd_get_fitness(self, *args, **kwargs)

    def get_fitness_statistics(self):
        """get_fitness_statistics(haploid_lowd self) -> stat"""
        return _FFPopSim.haploid_lowd_get_fitness_statistics(self)

    def __str__(self):
        """__str__(haploid_lowd self) -> char const *"""
        return _FFPopSim.haploid_lowd___str__(self)

    def __repr__(self):
        """__repr__(haploid_lowd self) -> char const *"""
        return _FFPopSim.haploid_lowd___repr__(self)

    L = property(_get_number_of_loci)
    N = property(_get_population_size)
    number_of_loci = property(_get_number_of_loci)
    population_size = property(_get_population_size)
    generation = property(_get_generation)

    def _set_allele_frequencies(self, *args, **kwargs):
        """_set_allele_frequencies(haploid_lowd self, int DIM1, unsigned long N) -> int"""
        return _FFPopSim.haploid_lowd__set_allele_frequencies(self, *args, **kwargs)

    def set_allele_frequencies(self, frequencies, N):
        '''Initialize the population in linkage equilibrium with allele frequencies.

        Parameters:
           - frequencies: an array of length L with all allele frequencies
           - N: set the population size to this value and, if still unset, the carrying
             capacity will be set to N. Defaults to carrying capacity if not given.

        .. note:: the population size is only used for resampling and has therefore
                  no effect on the speed of the simulation.
        '''
        if len(frequencies) != self.L:
            raise ValueError('The input array of allele frequencies has the wrong length.')
        if self._set_allele_frequencies(frequencies, N):
            raise RuntimeError('Error in the C++ function.')

    def _set_genotypes(self, *args, **kwargs):
        """_set_genotypes(haploid_lowd self, int len1, int len2) -> int"""
        return _FFPopSim.haploid_lowd__set_genotypes(self, *args, **kwargs)

    def set_genotypes(self, indices, counts):
        '''Initialize population with fixed counts for specific genotypes.

        Parameters:
        - indices: list of genotypes to set (e.g. 0 --> 00...0, L-1 --> 11...1)
        - counts: list of counts for those genotypes

        *Note*: the population size and, if not yet set, the carrying capacity will be set as the sum of the counts.
        *Note*: you can use Python binary notation for the indices, e.g. 0b0110 is 6.
        '''
        import numpy as np
        indices = np.asarray(indices, float)
        counts = np.asarray(counts, float)
        if len(indices) != len(counts):
            raise ValueError('Indices and counts must have the same length')
        if self._set_genotypes(indices, counts):
            raise RuntimeError('Error in the C++ function.')

    def set_recombination_rates(self, rates, model=2):
        '''Set the recombination rate(s).

    Parameters:
        - rates: if a double, the recombination rate at between any two loci; if an array,
          the locus-specific recombination rates
        - model: the recombination model to use (CROSSOVERS or SINGLE_CROSSOVER)

    .. note:: if locus-specific rates are specified, the array must have length
              (L-1) for linear chromosomes and length L for circular ones. The
              i-th element is the crossover rate between the i-th site and the
              (i+1)-th site.
        '''

        import numpy as np

        
        if model == 1:
            raise ValueError("Cannot assign rates to free recombination!")
        elif model not in (2, 3):
            raise ValueError("Model not recognized.")

        
        if self.circular:
            len_rates = self.L
        else:
            len_rates = self.L - 1

        
        if np.isscalar(rates):
            self._set_recombination_rates([rates] * len_rates, model)

        elif len(rates) != len_rates:
            raise ValueError("Expecting an array of length "+str(len_rates)+".")
        else:
            self._set_recombination_rates(rates, model)


    def get_mutation_rates(self, locus=None, direction=None):
        '''Get one or several mutation rates.

    Parameters:
        - locus: get only the mutation rate(s) of this locus
        - direction: get only the forward or backward mutation rate(s)

    Returns:
        - the mutation rate(s) requensted

    **Note**: if the mutation rates for all loci and/or directions are the same,
    this function will try to be smart and give you the answer you are looking for.
    In case of doubt, you will get a matrix (L x 2) with the full mutation rate
    landscape.
        '''

        import numpy as np
        if locus is not None:
            if not np.isscalar(locus):
                raise TypeError('Please select a *single* locus or no locus at all.')
            if direction is not None:
                return self._get_mutation_rate(locus, direction)
            else:
                mrs = tuple([self._get_mutation_rate(locus, d) for d in [0,1]])
                if mrs[0] == mrs[1]:
                    return mrs[0]
                else:
                    return mrs
        else:
            if direction is not None:
                mrs = np.array([self._get_mutation_rate(l, direction) for l in xrange(self.L)])
                if len(np.unique(mrs)) == 1:
                    return mrs[0]
                else:
                    return mrs
            else:
                mrs = np.array([[self._get_mutation_rate(l, d) for l in xrange(self.L)] for d in [0,1]])
                if len(np.unique(mrs)) == 1:
                    return mrs[0,0]
                else:
                    return mrs

    def _set_mutation_rates(self, *args, **kwargs):
        """_set_mutation_rates(haploid_lowd self, double * IN_ARRAY2) -> int"""
        return _FFPopSim.haploid_lowd__set_mutation_rates(self, *args, **kwargs)

    def set_mutation_rates(self, rates, rates_back=None):
        '''Set the mutation rate(s).

    Parameters:
        - rates:if a double, the mutation rate at any locus in both directions
          or, if rates_back is not None, only in the forward direction

          if a vector, the mutation rate is specified for each locus, the same
          in both directions or, if rates_back is not None, only in the
          forward direction

        - rates_back: mutation rate in the backward direction (global or
          locus-specific)
        '''

        import numpy as np
        L = self.L
        if np.isscalar(rates):
            if rates_back is None:
                ratesm = np.repeat(rates, L * 2).reshape(2,L)
            else:
                ratesm = np.vstack([np.repeat(rates, L), np.repeat(rates_back, L)])
        elif (np.rank(rates) != 1) or ((rates_back is not None) and (np.rank(rates_back) != 1)):
            raise ValueError('Please input one/two numbers or arrays.')
        else:
            if rates_back is None:
                ratesm = np.vstack([rates, rates])
            else:
                ratesm = np.vstack([rates, rates_back])

        if self._set_mutation_rates(ratesm):
            raise RuntimeError('Error in the C++ function.')

    def get_genotype_frequencies(self):
        '''Get the frequency of each genotype.'''
        import numpy as np
        return np.array([self.get_genotype_frequency(l) for l in xrange(1<<self.L)])

    def get_allele_frequencies(self):
        '''Get the frequencies of all + alleles'''
        import numpy as np
        return np.array([self.get_allele_frequency(l) for l in xrange(self.L)])

    def random_genomes(self, n_sample):
        '''Get random genomes according to their frequencies.
        
        Parameters:
            - n_sample: number of random genomes to sample
        
        Returns:
            - integers corresponding to random genomes in the population.
        '''
        import numpy as np
        counts = np.random.multinomial(n_sample, self.get_genotype_frequencies())
        ind = counts.nonzero()[0]
        counts = counts[ind]
        sample = np.concatenate([np.repeat(ind[i], counts[i]) for i in xrange(len(ind))])
        np.random.shuffle(sample)
        return sample

    def _get_fitnesses(self, *args, **kwargs):
        """_get_fitnesses(haploid_lowd self, int DIM1)"""
        return _FFPopSim.haploid_lowd__get_fitnesses(self, *args, **kwargs)

    def get_fitnesses(self):
        '''Get the fitness of all possible genotypes.'''
        return self._get_fitnesses(1<<self.L)

    def get_fitness_histogram(self, n_sample=1000, **kwargs):
        '''Get the histogram of the fitness in the population.

        Parameters:
            - n_sample: number of individual to sample at random from the population

        Returns:
           - h: numpy.histogram of fitness in the population
        '''
        import numpy as np

        
        gt = self.random_genomes(n_sample)

        
        fit = np.array([self.get_fitness(gt[i]) for i in xrange(n_sample)])

        return np.histogram(fit, bins=bins, **kwargs)


    def plot_fitness_histogram(self, axis=None, n_sample=1000, **kwargs):
        '''Plot the histogram of the fitness in the population.

        Parameters:
            - axis: use an already existing axis for the plot
            - n_sample: number of individual to sample at random from the population
            - kwargs: further optional keyword arguments to numpy.histograms
        '''

        import numpy as np
        import matplotlib.pyplot as plt

        
        gt = self.random_genomes(n_sample)

        
        fit = np.array([self.get_fitness(gt[i]) for i in xrange(n_sample)])

        
        if axis is None:
            fig = plt.figure()
            axis = fig.add_subplot(111)
            axis.set_title('Fitness histogram')
            axis.set_xlabel('Fitness')
        axis.hist(fit, **kwargs)


    def get_divergence_statistics(self, n_sample=1000):
        '''Get the mean and variance of the divergence in the population.

        Parameters:
            - n_sample: number of individuals to sample at random from the population

        Returns:
            - stat: structure with mean and variance of divergence in the population
        '''

        import numpy as np
        L = self.L

        
        gt = self.random_genomes(n_sample)

        
        div = np.array([binarify(gt[i], L).sum() for i in xrange(n_sample)], int)

        return stat(div.mean(), div.var())


    def get_divergence_histogram(self, bins=10, n_sample=1000, **kwargs):
        '''Get the histogram of the divergence in the population.

        Parameters:
            - bins: number of bins or list of bin edges (passed verbatim to numpy.histogram)
            - n_sample: number of individual to sample at random from the population
            - kwargs: further optional keyword arguments to numpy.histograms

        Returns:
           - h: numpy.histogram of divergence in the population

        *Note*: to get a normalized histogram, use the *density* keyword.
        '''

        import numpy as np
        L = self.L

        
        gt = self.random_genomes(n_sample)

        
        div = np.array([binarify(gt[i], L).sum() for i in xrange(n_sample)], int)

        return np.histogram(div, bins=bins, **kwargs)


    def plot_divergence_histogram(self, axis=None, n_sample=1000, **kwargs):
        '''Plot the histogram of the divergence in the population.

        Parameters:
            - axis: use an already existing axis for the plot
            - n_sample: number of individual to sample at random from the population
            - kwargs: further optional keyword arguments to numpy.histograms
        '''
        import numpy as np
        import matplotlib.pyplot as plt
        L = self.L

        
        gt = self.random_genomes(n_sample)

        
        div = np.array([binarify(gt[i], L).sum() for i in xrange(n_sample)], int)

        
        if axis is None:
            fig = plt.figure()
            axis = fig.add_subplot(111)
            axis.set_title('Divergence histogram')
            axis.set_xlabel('Divergence')
        
        if 'bins' not in kwargs:
            kwargs['bins'] = np.arange(10) * max(1, (div.max() + 1 - div.min()) / 10) + div.min()
        axis.hist(div, **kwargs)


    def get_diversity_statistics(self, n_sample=1000):
        '''Get the mean and variance of the diversity in the population.

        Parameters:
            - n_sample: number of individual to sample at random from the population

        Returns:
            - stat: structure with mean and variance of diversity in the population
        '''

        import numpy as np
        L = self.L

        
        gt1 = self.random_genomes(n_sample)
        gt2 = self.random_genomes(n_sample)

        
        div = np.array([binarify(gt1[i] ^ gt2[i], L).sum() for i in xrange(n_sample)], int)

        return stat(div.mean(), div.var())


    def get_diversity_histogram(self, bins=10, n_sample=1000, **kwargs):
        '''Get the histogram of the diversity in the population.

        Parameters:
            - bins: number of bins or list of bin edges (passed verbatim to numpy.histogram)
            - n_sample: number of individual to sample at random from the population
            - kwargs: further optional keyword arguments to numpy.histograms

        Returns:
           - h: numpy.histogram of diversity in the population

        *Note*: to get a normalized histogram, use the *density* keyword.
        '''

        import numpy as np
        L = self.L

        
        gt1 = self.random_genomes(n_sample)
        gt2 = self.random_genomes(n_sample)

        
        div = np.array([binarify(gt1[i] ^ gt2[i], L).sum() for i in xrange(n_sample)], int)

        
        return np.histogram(div, bins=bins, **kwargs)


    def plot_diversity_histogram(self, axis=None, n_sample=1000, **kwargs):
        '''Plot the histogram of the diversity in the population.

        Parameters:
            - axis: use an already existing axis for the plot
            - n_sample: number of individual to sample at random from the population
            - kwargs: further optional keyword arguments to numpy.histograms
        '''
        import numpy as np
        import matplotlib.pyplot as plt
        L = self.L

        
        gt1 = self.random_genomes(n_sample)
        gt2 = self.random_genomes(n_sample)

        
        div = np.array([binarify(gt1[i] ^ gt2[i], L).sum() for i in xrange(n_sample)], int)

        
        if axis is None:
            fig = plt.figure()
            axis = fig.add_subplot(111)
            axis.set_title('Diversity histogram')
            axis.set_xlabel('Diversity')
        
        if 'bins' not in kwargs:
            kwargs['bins'] = np.arange(10) * max(1, (div.max() + 1 - div.min()) / 10) + div.min()
        axis.hist(div, **kwargs)

    def _set_fitness_func(self, *args, **kwargs):
        """_set_fitness_func(haploid_lowd self, int len1, int len2) -> int"""
        return _FFPopSim.haploid_lowd__set_fitness_func(self, *args, **kwargs)

    def set_fitness_function(self, indices, vals):
        '''Set the fitness landscape at single points.

        Parameters:
        - indices: genotype to which the fitness values will be assigned
        - vals: fitness values to assign
        '''
        import numpy as np
        indices = np.asarray(indices, float)
        vals = np.asarray(vals, float)
        if len(indices) != len(vals):
            raise ValueError('Indices and values must have the same length')
        if self._set_fitness_func(indices, vals):
            raise RuntimeError('Error in the C++ function.')

    def set_fitness_additive(self, *args, **kwargs):
        """
        Set an additive fitness landscape

        Parameters:
            - coefficients: array/list of additive fitness coefficients. It must have length L.

        """
        return _FFPopSim.haploid_lowd_set_fitness_additive(self, *args, **kwargs)

haploid_lowd._get_number_of_loci = new_instancemethod(_FFPopSim.haploid_lowd__get_number_of_loci,None,haploid_lowd)
haploid_lowd._get_population_size = new_instancemethod(_FFPopSim.haploid_lowd__get_population_size,None,haploid_lowd)
haploid_lowd._get_generation = new_instancemethod(_FFPopSim.haploid_lowd__get_generation,None,haploid_lowd)
haploid_lowd._get_mutation_rate = new_instancemethod(_FFPopSim.haploid_lowd__get_mutation_rate,None,haploid_lowd)
haploid_lowd.set_wildtype = new_instancemethod(_FFPopSim.haploid_lowd_set_wildtype,None,haploid_lowd)
haploid_lowd._set_recombination_rates = new_instancemethod(_FFPopSim.haploid_lowd__set_recombination_rates,None,haploid_lowd)
haploid_lowd.evolve = new_instancemethod(_FFPopSim.haploid_lowd_evolve,None,haploid_lowd)
haploid_lowd.evolve_norec = new_instancemethod(_FFPopSim.haploid_lowd_evolve_norec,None,haploid_lowd)
haploid_lowd.evolve_deterministic = new_instancemethod(_FFPopSim.haploid_lowd_evolve_deterministic,None,haploid_lowd)
haploid_lowd.get_genotype_frequency = new_instancemethod(_FFPopSim.haploid_lowd_get_genotype_frequency,None,haploid_lowd)
haploid_lowd.get_allele_frequency = new_instancemethod(_FFPopSim.haploid_lowd_get_allele_frequency,None,haploid_lowd)
haploid_lowd.get_pair_frequency = new_instancemethod(_FFPopSim.haploid_lowd_get_pair_frequency,None,haploid_lowd)
haploid_lowd.get_moment = new_instancemethod(_FFPopSim.haploid_lowd_get_moment,None,haploid_lowd)
haploid_lowd.get_LD = new_instancemethod(_FFPopSim.haploid_lowd_get_LD,None,haploid_lowd)
haploid_lowd.get_chi = new_instancemethod(_FFPopSim.haploid_lowd_get_chi,None,haploid_lowd)
haploid_lowd.get_chi2 = new_instancemethod(_FFPopSim.haploid_lowd_get_chi2,None,haploid_lowd)
haploid_lowd.genotype_entropy = new_instancemethod(_FFPopSim.haploid_lowd_genotype_entropy,None,haploid_lowd)
haploid_lowd.allele_entropy = new_instancemethod(_FFPopSim.haploid_lowd_allele_entropy,None,haploid_lowd)
haploid_lowd.get_fitness = new_instancemethod(_FFPopSim.haploid_lowd_get_fitness,None,haploid_lowd)
haploid_lowd.get_fitness_statistics = new_instancemethod(_FFPopSim.haploid_lowd_get_fitness_statistics,None,haploid_lowd)
haploid_lowd.__str__ = new_instancemethod(_FFPopSim.haploid_lowd___str__,None,haploid_lowd)
haploid_lowd.__repr__ = new_instancemethod(_FFPopSim.haploid_lowd___repr__,None,haploid_lowd)
haploid_lowd._set_allele_frequencies = new_instancemethod(_FFPopSim.haploid_lowd__set_allele_frequencies,None,haploid_lowd)
haploid_lowd._set_genotypes = new_instancemethod(_FFPopSim.haploid_lowd__set_genotypes,None,haploid_lowd)
haploid_lowd._set_mutation_rates = new_instancemethod(_FFPopSim.haploid_lowd__set_mutation_rates,None,haploid_lowd)
haploid_lowd._get_fitnesses = new_instancemethod(_FFPopSim.haploid_lowd__get_fitnesses,None,haploid_lowd)
haploid_lowd._set_fitness_func = new_instancemethod(_FFPopSim.haploid_lowd__set_fitness_func,None,haploid_lowd)
haploid_lowd.set_fitness_additive = new_instancemethod(_FFPopSim.haploid_lowd_set_fitness_additive,None,haploid_lowd)
haploid_lowd_swigregister = _FFPopSim.haploid_lowd_swigregister
haploid_lowd_swigregister(haploid_lowd)

HCF_MEMERR = _FFPopSim.HCF_MEMERR
HCF_BADARG = _FFPopSim.HCF_BADARG
HCF_VERBOSE = _FFPopSim.HCF_VERBOSE
WORDLENGTH = _FFPopSim.WORDLENGTH
HP_VERBOSE = _FFPopSim.HP_VERBOSE
NO_GENOTYPE = _FFPopSim.NO_GENOTYPE
HP_MINAF = _FFPopSim.HP_MINAF
MAX_DELTAFITNESS = _FFPopSim.MAX_DELTAFITNESS
MAX_POPSIZE = _FFPopSim.MAX_POPSIZE
HP_NOTHING = _FFPopSim.HP_NOTHING
HP_RANDOM_SAMPLE_FRAC = _FFPopSim.HP_RANDOM_SAMPLE_FRAC
HP_BADARG = _FFPopSim.HP_BADARG
HP_MEMERR = _FFPopSim.HP_MEMERR
HP_EXPLOSIONWARN = _FFPopSim.HP_EXPLOSIONWARN
HP_EXTINCTERR = _FFPopSim.HP_EXTINCTERR
HP_NOBINSERR = _FFPopSim.HP_NOBINSERR
HP_WRONGBINSERR = _FFPopSim.HP_WRONGBINSERR
HP_RUNTIMEERR = _FFPopSim.HP_RUNTIMEERR
class clone(object):
    """Clone of isogenetic individuals"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    _trait = _swig_property(_FFPopSim.clone__trait_get, _FFPopSim.clone__trait_set)
    fitness = _swig_property(_FFPopSim.clone_fitness_get, _FFPopSim.clone_fitness_set)
    clone_size = _swig_property(_FFPopSim.clone_clone_size_get, _FFPopSim.clone_clone_size_set)
    def __init__(self, n_traits=0): 
        """Clone of isogenetic individuals"""
        _FFPopSim.clone_swiginit(self,_FFPopSim.new_clone(n_traits))
    def __eq__(self, *args, **kwargs):
        """__eq__(clone self, clone other) -> bool"""
        return _FFPopSim.clone___eq__(self, *args, **kwargs)

    def __ne__(self, *args, **kwargs):
        """__ne__(clone self, clone other) -> bool"""
        return _FFPopSim.clone___ne__(self, *args, **kwargs)

    def __lt__(self, *args, **kwargs):
        """__lt__(clone self, clone other) -> bool"""
        return _FFPopSim.clone___lt__(self, *args, **kwargs)

    def __gt__(self, *args, **kwargs):
        """__gt__(clone self, clone other) -> bool"""
        return _FFPopSim.clone___gt__(self, *args, **kwargs)

    def __str__(self):
        """__str__(clone self) -> char const *"""
        return _FFPopSim.clone___str__(self)

    def __repr__(self):
        """__repr__(clone self) -> char const *"""
        return _FFPopSim.clone___repr__(self)

    def _get_number_of_traits(self):
        """Number of traits (read-only)"""
        return _FFPopSim.clone__get_number_of_traits(self)

    number_of_traits = property(_get_number_of_traits)

    def _get_trait(self, *args, **kwargs):
        """_get_trait(clone self, int DIM1)"""
        return _FFPopSim.clone__get_trait(self, *args, **kwargs)

    @property
    def trait(self):
        '''Traits vector of the clone'''
        return self._get_trait(self.number_of_traits)

    def _get_genotype_length(self):
        """_get_genotype_length(clone self) -> int"""
        return _FFPopSim.clone__get_genotype_length(self)

    def _get_genotype(self, *args, **kwargs):
        """_get_genotype(clone self, int DIM1)"""
        return _FFPopSim.clone__get_genotype(self, *args, **kwargs)

    def _set_genotype(self, *args, **kwargs):
        """_set_genotype(clone self, boost::dynamic_bitset< > genotype_in)"""
        return _FFPopSim.clone__set_genotype(self, *args, **kwargs)

    @property
    def genotype(self):
        '''Genotype of the clone'''
        import numpy as np
        return np.array(self._get_genotype(self._get_genotype_length()), bool)


    @genotype.setter
    def genotype(self, genotype):
        self._set_genotype(genotype)

    __swig_destroy__ = _FFPopSim.delete_clone
clone.__eq__ = new_instancemethod(_FFPopSim.clone___eq__,None,clone)
clone.__ne__ = new_instancemethod(_FFPopSim.clone___ne__,None,clone)
clone.__lt__ = new_instancemethod(_FFPopSim.clone___lt__,None,clone)
clone.__gt__ = new_instancemethod(_FFPopSim.clone___gt__,None,clone)
clone.__str__ = new_instancemethod(_FFPopSim.clone___str__,None,clone)
clone.__repr__ = new_instancemethod(_FFPopSim.clone___repr__,None,clone)
clone._get_number_of_traits = new_instancemethod(_FFPopSim.clone__get_number_of_traits,None,clone)
clone._get_trait = new_instancemethod(_FFPopSim.clone__get_trait,None,clone)
clone._get_genotype_length = new_instancemethod(_FFPopSim.clone__get_genotype_length,None,clone)
clone._get_genotype = new_instancemethod(_FFPopSim.clone__get_genotype,None,clone)
clone._set_genotype = new_instancemethod(_FFPopSim.clone__set_genotype,None,clone)
clone_swigregister = _FFPopSim.clone_swigregister
clone_swigregister(clone)

class haploid_highd(object):
    """
    Class for high-dimensional population genetics (genomes larger than ~20 loci).

    This class is the main object for simulating the evolution of populations with
    many loci (more than ~20). The class offers a number of functions, but an
    example will explain the basic idea::

       ######################################
       #  EXAMPLE SCRIPT FOR HAPLOID_HIGHD  #
       ######################################
       import numpy as np
       import matplotlib.pyplot as plt
       import FFPopSim as h
       c = h.haploid_highd(300)       # 300 loci
       pop.set_wildtype(1000)         # start with 1000 wildtype individuals
       pop.mutation_rate = 1e-4       # mutation rate per site per generation
       pop.outcrossing_rate = 1e-1    # probability of sexual reproduction per gen
       pop.crossover_rate = 1e-2      # probability of crossover per site per gen
       pop.evolve(100)                # evolve for 100 generations
       c.plot_divergence_histogram()
       plt.show()
       ######################################

    Populations can have a number of phenotypic traits that contribute to the fitness
    of each individual. The function that calculates fitness from the phenotype
    identifies fitness with the first trait only by default. The user is, however,
    free to subclass haploid_highd in C++ (as it is done in hivpopulation) and
    implement their own phenotype -> fitness function.

    In addition, the trait landscapes describe the genotype -> phenotype maps.
    These can be set directly from Python (since the genotypic space has a finite
    number of elements).

    **Note**: fitness is not a phenotypic trait directly, but rather a function of *all*
    phenotypic traits together. 

    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, L=0, rng_seed=0, number_of_traits=1): 
        """
        Construct a high-dimensional population with certain parameters.

        Parameters:
        - L     length of the genome(number of loci)
        - rng_seed      seed for the random generator. If zero (default) pick a random number
        - number_of_traits      number of phenotypic traits, defaults to one

        """
        _FFPopSim.haploid_highd_swiginit(self,_FFPopSim.new_haploid_highd(L, rng_seed, number_of_traits))
    __swig_destroy__ = _FFPopSim.delete_haploid_highd
    carrying_capacity = _swig_property(_FFPopSim.haploid_highd_carrying_capacity_get, _FFPopSim.haploid_highd_carrying_capacity_set)
    mutation_rate = _swig_property(_FFPopSim.haploid_highd_mutation_rate_get, _FFPopSim.haploid_highd_mutation_rate_set)
    outcrossing_rate = _swig_property(_FFPopSim.haploid_highd_outcrossing_rate_get, _FFPopSim.haploid_highd_outcrossing_rate_set)
    crossover_rate = _swig_property(_FFPopSim.haploid_highd_crossover_rate_get, _FFPopSim.haploid_highd_crossover_rate_set)
    recombination_model = _swig_property(_FFPopSim.haploid_highd_recombination_model_get, _FFPopSim.haploid_highd_recombination_model_set)
    circular = _swig_property(_FFPopSim.haploid_highd_circular_get, _FFPopSim.haploid_highd_circular_set)
    def _get_number_of_loci(self):
        """Number of loci (read-only)"""
        return _FFPopSim.haploid_highd__get_number_of_loci(self)

    def _get_population_size(self):
        """Population size (read-only)"""
        return _FFPopSim.haploid_highd__get_population_size(self)

    def _get_generation(self):
        """Current generation (read-only)"""
        return _FFPopSim.haploid_highd__get_generation(self)

    def _get_number_of_clones(self):
        """Number of clones (read-only)"""
        return _FFPopSim.haploid_highd__get_number_of_clones(self)

    def _get_number_of_traits(self):
        """Number of traits (read-only)"""
        return _FFPopSim.haploid_highd__get_number_of_traits(self)

    def set_wildtype(self, *args, **kwargs):
        """
        Set up a population of wildtype individuals

        Parameters:
           - N: the number of individuals and carrying capacity

        """
        return _FFPopSim.haploid_highd_set_wildtype(self, *args, **kwargs)

    def add_genotypes(self, *args, **kwargs):
        """
        Add new individuals to the population with certain genotypes

        Parameters:
           - gt: genotype to add to the population
           - n: number of new individuals carrying that genotype

        .. note:: gt is an array/list that must be convertible into a bool.

        """
        return _FFPopSim.haploid_highd_add_genotypes(self, *args, **kwargs)

    def add_trait_coefficient(self, *args, **kwargs):
        """
        Add a coefficient to the trait landscape.

        Parameters:
           - value: value of the coefficient
           - loci: array/list of loci indexed by the coefficient.
           - t: number of the trait to be changed

        **Example**: to set a second-order epistatic term :math:`t_{ij} = 0.1`, use ``add_trait_coefficient(0.1, [i, j])``.

        .. warning:: the -/+ basis is used throughout the library. If you are used to the 0/1 basis, keep in mind that the interaction series-expansion is different.

        """
        return _FFPopSim.haploid_highd_add_trait_coefficient(self, *args, **kwargs)

    def clear_trait(self, t=0):
        """
        Clear a trait landscape.

        Parameters:
           - t: number of the trait to be cleared

        """
        return _FFPopSim.haploid_highd_clear_trait(self, t)

    def clear_traits(self):
        """Clear all trait landscapes"""
        return _FFPopSim.haploid_highd_clear_traits(self)

    def set_random_trait_epistasis(self, *args, **kwargs):
        """
        Set a random epistatic term in the genotype-phenotype map. This is meant as an approximation to multi-locus epistasis to which many locus sets contribute. It assigns to each genotype a reprodrucible fitness component drawn from a Gaussian distribution.

        Parameters:
           - epistasis_std: standard deviation of the random epistatic terms

        .. note:: the epistatic terms will be Gaussian distributed around zero with the given standard deviation.

        """
        return _FFPopSim.haploid_highd_set_random_trait_epistasis(self, *args, **kwargs)

    def add_fitness_coefficient(self, *args, **kwargs):
        """Shortcut for add_trait_coefficient when there is only one trait"""
        return _FFPopSim.haploid_highd_add_fitness_coefficient(self, *args, **kwargs)

    def clear_fitness(self):
        """Shortcut for clear_trait when there is only one trait"""
        return _FFPopSim.haploid_highd_clear_fitness(self)

    def set_random_epistasis(self, *args, **kwargs):
        """Shortcut for set_random_trait_epistasis when there is only one trait"""
        return _FFPopSim.haploid_highd_set_random_epistasis(self, *args, **kwargs)

    def _evolve(self, gen=1):
        """_evolve(haploid_highd self, int gen=1) -> int"""
        return _FFPopSim.haploid_highd__evolve(self, gen)

    def bottleneck(self, *args, **kwargs):
        """
        Make the population undergo a bottleneck

        Parameters:
           - size_of_bottleneck: the number of individuals at the bottleneck

        """
        return _FFPopSim.haploid_highd_bottleneck(self, *args, **kwargs)

    def calc_stat(self):
        """Calculate trait and fitness statistics for the population"""
        return _FFPopSim.haploid_highd_calc_stat(self)

    def unique_clones(self):
        """
        Recompress the clone structure

        During its evolution, identical clones might be generated by different routes at
        different times. This function merges any such duplicates into unique clones with
        the size equal to the sum of the sizes of the duplicates.

        """
        return _FFPopSim.haploid_highd_unique_clones(self)

    def random_clone(self):
        """
        Get a random clone

        Returns:
           - clone: index of the random clone

        """
        return _FFPopSim.haploid_highd_random_clone(self)

    def get_diversity_statistics(self, n_sample=1000):
        """
        Get the mean and variance of the diversity in the population.

        Parameters:
           - n_sample: number of individuals to sample at random from the population

        Returns:
           - stat: structure with mean and variance of diversity in the population

        """
        return _FFPopSim.haploid_highd_get_diversity_statistics(self, n_sample)

    def get_divergence_statistics(self, n_sample=1000):
        """
        Get the mean and variance of the divergence in the population.

        Parameters:
           - n_sample: number of individuals to sample at random from the population

        Returns:
           - stat: structure with mean and variance of divergence in the population

        """
        return _FFPopSim.haploid_highd_get_divergence_statistics(self, n_sample)

    def get_allele_frequency(self, *args, **kwargs):
        """
        Get the frequency of the + allele at the selected locus

        Parameters:
           - locus: locus whose frequency of the + allele is to be returned

        Returns:
           - frequency: allele frequency in the population

        """
        return _FFPopSim.haploid_highd_get_allele_frequency(self, *args, **kwargs)

    def get_pair_frequency(self, *args, **kwargs):
        """
        Get the joint frequency of two + alleles

        Parameters:
            - locus1: first locus
            - locus2: second locus

        Returns:
            - the joint frequency of the + alleles

        """
        return _FFPopSim.haploid_highd_get_pair_frequency(self, *args, **kwargs)

    def get_chi(self, *args, **kwargs):
        """
        Get chi of an allele in the -/+ basis

        Parameters:
            - locus: locus whose chi is to be computed

        Returns:
            - the chi of that allele, :math:`\chi_i := \left<s_i\right>`, where :math:`s_i \in \{-1, 1\}`.

        """
        return _FFPopSim.haploid_highd_get_chi(self, *args, **kwargs)

    def _get_participation_ratio(self):
        """Participation ratio (read-only)"""
        return _FFPopSim.haploid_highd__get_participation_ratio(self)

    def get_fitness(self, *args, **kwargs):
        """
        Get the fitness of an individual

        Parameters:
           - n: index of the clone whose fitness is to be computed

        Returns:
           - fitness: fitness value of that clone

        """
        return _FFPopSim.haploid_highd_get_fitness(self, *args, **kwargs)

    def get_clone_size(self, *args, **kwargs):
        """
        Get the size of a clone

        Parameters:
           - n: index of the clone

        Returns:
           - size: size of the selected clone

        """
        return _FFPopSim.haploid_highd_get_clone_size(self, *args, **kwargs)

    def get_trait(self, *args, **kwargs):
        """
        Get a trait of an individual

        Parameters:
           - n: index of the clone whose trait is to be computed
           - t: trait to be computed

        Returns:
           - trait: value of that trait for that clone

        """
        return _FFPopSim.haploid_highd_get_trait(self, *args, **kwargs)

    def get_fitness_statistics(self):
        """
        Get the mean and variance of the fitness in the population.

        Returns:
           - stat: structure with mean and variance of the fitness in the population

        """
        return _FFPopSim.haploid_highd_get_fitness_statistics(self)

    def get_trait_statistics(self, t=0):
        """
        Get the mean and variance of a trait in the population.

        Parameters:
           - t: number of the trait whose statistics are to be computed

        Returns:
           - stat: structure with mean and variance of the trait in the population

        """
        return _FFPopSim.haploid_highd_get_trait_statistics(self, t)

    def get_trait_covariance(self, *args, **kwargs):
        """
        Get the covariance of two traits in the population.

        Parameters:
           - t1: first trait
           - t2: second trait

        Returns:
           - cov: the covariance of the two traits

        """
        return _FFPopSim.haploid_highd_get_trait_covariance(self, *args, **kwargs)

    def _get_max_fitness(self):
        """Maximal fitness in the population (read-only)"""
        return _FFPopSim.haploid_highd__get_max_fitness(self)

    def _update_traits(self):
        """_update_traits(haploid_highd self)"""
        return _FFPopSim.haploid_highd__update_traits(self)

    def _update_fitness(self):
        """_update_fitness(haploid_highd self)"""
        return _FFPopSim.haploid_highd__update_fitness(self)

    def __str__(self):
        """__str__(haploid_highd self) -> char const *"""
        return _FFPopSim.haploid_highd___str__(self)

    def __repr__(self):
        """__repr__(haploid_highd self) -> char const *"""
        return _FFPopSim.haploid_highd___repr__(self)

    L = property(_get_number_of_loci)
    N = property(_get_population_size)
    number_of_loci = property(_get_number_of_loci)
    population_size = property(_get_population_size)
    generation = property(_get_generation)
    number_of_clones = property(_get_number_of_clones)
    number_of_traits = property(_get_number_of_traits)
    max_fitness = property(_get_max_fitness)
    participation_ratio = property(_get_participation_ratio)

    def _set_allele_frequencies(self, *args, **kwargs):
        """_set_allele_frequencies(haploid_highd self, double * IN_ARRAY1, int n_o_genotypes) -> int"""
        return _FFPopSim.haploid_highd__set_allele_frequencies(self, *args, **kwargs)

    def set_allele_frequencies(self, frequencies, N):
        '''Initialize the population according to the given allele frequencies in linkage equilibrium.

        Parameters:
           - frequencies: an array of length L with all allele frequencies
           - N: the number of individuals and carrying capacity
        '''

        if len(frequencies) != self.L:
                raise ValueError('Please input an L dimensional list of allele frequencies.')
        if self._set_allele_frequencies(frequencies, N):
            raise RuntimeError('Error in the C++ function.')

    def _set_genotypes(self, *args, **kwargs):
        """_set_genotypes(haploid_highd self, int len1, int len2) -> int"""
        return _FFPopSim.haploid_highd__set_genotypes(self, *args, **kwargs)

    def set_genotypes(self, genotypes, counts):
        '''Initialize population with fixed counts for specific genotypes.

        Parameters:
           - indices: list of genotypes to set. Genotypes themselves are lists of alleles,
             e.g. [[0,0,1,0], [0,1,1,1]] for genotypes 0010 and 0111   
           - counts: list of the number at which each of those genotypes it to be present

        .. note:: the population size and the carrying capacity (if not already set) are set as the sum of the counts.
        .. note:: you can use Python binary notation for the indices, e.g. 0b0110 = 6.

        **Example**: if you want to initialize 200 individuals with genotype 001 and 300 individuals
                     with genotype 110, you can use ``set_genotypes([[0,0,1], [1,1,0]], [200, 300])``
        '''

        import numpy as np
        genotypes = np.array(genotypes, float, copy=False, ndmin=2)
        counts = np.asarray(counts, float)
        if len(genotypes) != len(counts):
            raise ValueError('Indices and counts must have the same length')
        if self._set_genotypes(genotypes.flatten(), counts):
            raise RuntimeError('Error in the C++ function.')

    def evolve(self, gen=1):
            '''Evolve for some generations.

            Parameters:
               - gen: number of generations, defaults to one
            '''

            if self._evolve(gen):
                    raise RuntimeError('Error in the C++ function.')
            else:
                    self.calc_stat()

    def _get_allele_frequencies(self, *args, **kwargs):
        """_get_allele_frequencies(haploid_highd self, double * ARGOUT_ARRAY1)"""
        return _FFPopSim.haploid_highd__get_allele_frequencies(self, *args, **kwargs)

    def get_allele_frequencies(self):
        '''Get all allele frequencies'''
        return self._get_allele_frequencies(self.L)

    def _get_genotype(self, *args, **kwargs):
        """_get_genotype(haploid_highd self, unsigned int n, short * ARGOUT_ARRAY1)"""
        return _FFPopSim.haploid_highd__get_genotype(self, *args, **kwargs)

    def get_genotype(self, n):
        '''Get a genotype from the population

        Parameters:
           - n: index of the clone whose genotype is to be returned

        Returns:
           - gt: boolean array of the genotype
        '''

        return self._get_genotype(n, self.number_of_loci)


    def get_genotypes(self, ind=None):
        '''Get genotypes of the population.

        Parameters:
           - ind: if a scalar, a single genotype corresponding to clone ind is returned;
             otherwise, several genotypes are returned (default: all)
        '''

        import numpy as np
        L = self.number_of_loci
        if np.isscalar(ind):
            return np.array(self._get_genotype(ind, L), bool)

        if ind is None:
            ind = xrange(self.number_of_clones)
        genotypes = np.zeros((len(ind), L), bool)
        for i, indi in enumerate(ind):
            genotypes[i] = self._get_genotype(indi, L)
        return genotypes

    def _get_additive_trait(self, *args, **kwargs):
        """_get_additive_trait(haploid_highd self, double * ARGOUT_ARRAY1, int t)"""
        return _FFPopSim.haploid_highd__get_additive_trait(self, *args, **kwargs)

    def get_additive_trait(self, t=0):
        '''Get an array with the additive coefficients of all loci of a trait. 

        Parameters:
           - t: number of the trait

        Returns:
           - coefficients: array of additive coefficients for the selected trait
        '''
        return self._get_additive_trait(self.L, t)

    def set_additive_trait(self, *args, **kwargs):
        """
        Set the additive part of a trait

        Parameters:
           - coefficients: array of coefficients for the trait (of length L). All previous additive coefficents are erased
           - t: number of the trait to set

        """
        return _FFPopSim.haploid_highd_set_additive_trait(self, *args, **kwargs)

    def set_additive_fitness(self, *args, **kwargs):
        """Shortcut for set_additive_trait when there is only one trait"""
        return _FFPopSim.haploid_highd_set_additive_fitness(self, *args, **kwargs)

    def _get_fitnesses(self, *args, **kwargs):
        """_get_fitnesses(haploid_highd self, int DIM1)"""
        return _FFPopSim.haploid_highd__get_fitnesses(self, *args, **kwargs)

    def get_fitnesses(self):
            '''Get the fitness of all clones.'''
            return self._get_fitnesses(self.number_of_clones)

    def _get_clone_sizes(self, *args, **kwargs):
        """_get_clone_sizes(haploid_highd self, int DIM1)"""
        return _FFPopSim.haploid_highd__get_clone_sizes(self, *args, **kwargs)

    def get_clone_sizes(self):
            '''Get the fitness of all clones.'''
            return self._get_clone_sizes(self.number_of_clones)

    def distance_Hamming(self, clone_gt1, clone_gt2, chunks=None, every=1):
        '''Calculate the Hamming distance between two genotypes

        Parameters:
           - clone_gt1: index of the clone corresponding to the first genotype
           - clone_gt2: index of the clone corresponding to the second genotype
           - chunks: list of pairs delimiting the genetic areas to include
           - every: do the comparison only on certain sites

        **Example**: to calculate the distance between the first two clones
        limited to third codon positions between locus 90 and 200, use:
        ``distance_Hamming(0, 1, chunks=[92, 200], every=3)``.
        '''
        import numpy as np
        if np.isscalar(clone_gt1):
            genotypes = self.get_genotypes((clone_gt1, clone_gt2))
            clone_gt1 = genotypes[0]
            clone_gt2 = genotypes[1]

        if chunks is not None:
            ind = np.zeros(clones.shape[1], bool)
            for chunk in chunks:
                inde = np.arange(chunk[1] - chunk[0])
                inde = inde[(inde % every) == 0] + chunk[0]
                ind[inde] = True
            clone_gt1 = clone_gt1[ind]
            clone_gt2 = clone_gt2[ind]
        return (clone_gt1 != clone_gt2).sum()

    def random_genomes(self, n):
        '''Get random genomes from the population

        Parameters:
           - n: number of random genomes to compute

        Returns:
           - gts: (n x L) bool matrix with the n genotypes
        '''

        import numpy as np
        L = self.number_of_loci
        genotypes = np.zeros((n, L), bool)
        for i in xrange(genotypes.shape[0]):
            genotypes[i] = self._get_genotype(self.random_clone(), L)
        return genotypes

    def random_clones(self, *args, **kwargs):
        """
        Get random clones

        Parameters:
           - n: number of random clones to return

        Returns:
           - clones: clone indices

        """
        return _FFPopSim.haploid_highd_random_clones(self, *args, **kwargs)

    def get_fitness_histogram(self, bins=10, n_sample=1000, **kwargs):
        '''Calculate the fitness histogram.

        Parameters:
           - bins: number or array of bins to be used in the histogram (see also numpy.histogram)
           - n_sample: number of individuals to sample

        Returns:
           - h: numpy.histogram of fitness in the population
        '''

        import numpy as np
        fit = [self.get_fitness(self.random_clone()) for i in xrange(n_sample)]
        h = np.histogram(fit, bins=bins, **kwargs)
        return h
        
        
    def plot_fitness_histogram(self, axis=None, n_sample=1000, **kwargs):
        '''Plot a distribution of fitness in the population.

        Parameters:
           - axis: an axis to use. A new figure is created by default
           - n_sample: number of individuals to sample
           - kwargs: further optional keyword arguments to matplotlib.pyplot.hist

        Returns:
           - return value of axis.hist(...)
        '''

        import matplotlib.pyplot as plt
        fit = [self.get_fitness(self.random_clone()) for i in xrange(n_sample)]
        
        if axis is None:
            fig = plt.figure()
            axis = fig.add_subplot(111)
            axis.set_title('Fitness histogram')
            axis.set_xlabel('Fitness')
        return axis.hist(fit, **kwargs)
        
        
    def get_divergence_histogram(self, bins=10, chunks=None, every=1, n_sample=1000, **kwargs):
        '''Get the divergence histogram restricted to those chunks of the genome.

        Parameters:
           - bins: number or array of bins to be used in the histogram (see also numpy.histogram)
           - chunks: restrict analysis to some chunk in the genome. It must be an n x 2 matrix with
                     the initial and (final+1) positions of the chunks
           - every: restrict analysis to every X positions. For instance, if every third site is neutral,
                    this argument can be used to only look at those neutral sites
           - n_sample: number of individuals to sample
           - kwargs: further optional keyword arguments to numpy.histogram

        Returns:
           - h: numpy.histogram of divergence in the population
        '''

        import numpy as np
        
        
        if chunks is not None:
            chunks = np.asarray(chunks)
            if (np.rank(chunks) != 2) or (chunks.shape[1] != 2):
                raise ValueError('Please input an N x 2 matrix with the chunks initial and (final+1) positions')
        
        
        genotypes = self.random_genomes(n_sample)
        
        
        if chunks is not None:
            ind = np.zeros(genotypes.shape[1], bool)
            for chunk in chunks:
                inde = np.arange(chunk[1] - chunk[0])
                inde = inde[(inde % every) == 0] + chunk[0]
                ind[inde] = True
            genotypes = genotypes[:,ind]
        
        
        div = genotypes.sum(axis=1)
        
        
        return np.histogram(div, bins=bins, **kwargs)
        
        
    def plot_divergence_histogram(self, axis=None, n_sample=1000, **kwargs):
        '''Plot the divergence histogram.

        Parameters:
           - axis: an axis to use. A new figure is created by default
           - n_sample: number of individuals to sample
           - kwargs: further optional keyword arguments to matplotlib.pyplot.hist
        
        Returns:
           - return value of axis.hist(...)
        '''

        import matplotlib.pyplot as plt
        import numpy as np
        genotypes = self.random_genomes(n_sample)
        div = genotypes.sum(axis=1)
         
        if axis is None:
            fig = plt.figure()
            axis = fig.add_subplot(111)
            axis.set_title('Divergence histogram')
            axis.set_xlabel('Divergence')
        
        if 'bins' not in kwargs:
            kwargs['bins'] = np.arange(10) * max(1, (div.max() + 1 - div.min()) / 10) + div.min()
        return axis.hist(div, **kwargs)
        
        
    def get_diversity_histogram(self, bins=10, chunks=None, every=1, n_sample=1000, **kwargs):
        '''Get the diversity histogram restricted to those chunks of the genome.

        Parameters:
           - bins: number or array of bins to be used in the histogram (see also numpy.histogram)
           - chunks: restrict analysis to some chunk in the genome. It must be an n x 2 matrix with
                     the initial and (final+1) positions of the chunks
           - every: restrict analysis to every X positions. For instance, if every third site is neutral,
                    this argument can be used to only look at those neutral sites
           - n_sample: number of individuals to sample
           - kwargs: further optional keyword arguments to numpy.histogram

        Returns:
           - h: numpy.histogram of diversity in the population
        '''

        import numpy as np
        
        
        if chunks is not None:
            chunks = np.asarray(chunks)
            if (np.rank(chunks) != 2) or (chunks.shape[1] != 2):
                raise ValueError('Please input an N x 2 matrix with the chunks initial and (final+1) positions')
        
        
        genotypes = self.random_genomes(2 * n_sample)
        
        
        if chunks is not None:
            ind = np.zeros(genotypes.shape[1], bool)
            for chunk in chunks:
                inde = np.arange(chunk[1] - chunk[0])
                inde = inde[(inde % every) == 0] + chunk[0]
                ind[inde] = True
            genotypes = genotypes[:,ind]
        
        
        genotypes1 = genotypes[:genotypes.shape[0] / 2]
        genotypes2 = genotypes[-genotypes1.shape[0]:]
        div = (genotypes1 != genotypes2).sum(axis=1)
        
        
        return np.histogram(div, bins=bins, **kwargs)


    def plot_diversity_histogram(self, axis=None, n_sample=1000, **kwargs):
        '''Plot the diversity histogram.

        Parameters:
           - axis: an axis to use. A new figure is created by default
           - n_sample: number of individuals to sample
           - kwargs: further optional keyword arguments to matplotlib.pyplot.hist
        
        Returns:
           - return value of axis.hist(...)
        '''

        import matplotlib.pyplot as plt
        import numpy as np
        genotypes1 = self.random_genomes(n_sample)
        genotypes2 = self.random_genomes(n_sample)
        div = (genotypes1 != genotypes2).sum(axis=1)
        
        if axis is None:
            fig = plt.figure()
            axis = fig.add_subplot(111)
            axis.set_title('Diversity histogram')
            axis.set_xlabel('Diversity')
        
        if 'bins' not in kwargs:
            kwargs['bins'] = np.arange(10) * max(1, (div.max() + 1 - div.min()) / 10) + div.min()
        return axis.hist(div, **kwargs)

haploid_highd._get_number_of_loci = new_instancemethod(_FFPopSim.haploid_highd__get_number_of_loci,None,haploid_highd)
haploid_highd._get_population_size = new_instancemethod(_FFPopSim.haploid_highd__get_population_size,None,haploid_highd)
haploid_highd._get_generation = new_instancemethod(_FFPopSim.haploid_highd__get_generation,None,haploid_highd)
haploid_highd._get_number_of_clones = new_instancemethod(_FFPopSim.haploid_highd__get_number_of_clones,None,haploid_highd)
haploid_highd._get_number_of_traits = new_instancemethod(_FFPopSim.haploid_highd__get_number_of_traits,None,haploid_highd)
haploid_highd.set_wildtype = new_instancemethod(_FFPopSim.haploid_highd_set_wildtype,None,haploid_highd)
haploid_highd.add_genotypes = new_instancemethod(_FFPopSim.haploid_highd_add_genotypes,None,haploid_highd)
haploid_highd.add_trait_coefficient = new_instancemethod(_FFPopSim.haploid_highd_add_trait_coefficient,None,haploid_highd)
haploid_highd.clear_trait = new_instancemethod(_FFPopSim.haploid_highd_clear_trait,None,haploid_highd)
haploid_highd.clear_traits = new_instancemethod(_FFPopSim.haploid_highd_clear_traits,None,haploid_highd)
haploid_highd.set_random_trait_epistasis = new_instancemethod(_FFPopSim.haploid_highd_set_random_trait_epistasis,None,haploid_highd)
haploid_highd.add_fitness_coefficient = new_instancemethod(_FFPopSim.haploid_highd_add_fitness_coefficient,None,haploid_highd)
haploid_highd.clear_fitness = new_instancemethod(_FFPopSim.haploid_highd_clear_fitness,None,haploid_highd)
haploid_highd.set_random_epistasis = new_instancemethod(_FFPopSim.haploid_highd_set_random_epistasis,None,haploid_highd)
haploid_highd._evolve = new_instancemethod(_FFPopSim.haploid_highd__evolve,None,haploid_highd)
haploid_highd.bottleneck = new_instancemethod(_FFPopSim.haploid_highd_bottleneck,None,haploid_highd)
haploid_highd.calc_stat = new_instancemethod(_FFPopSim.haploid_highd_calc_stat,None,haploid_highd)
haploid_highd.unique_clones = new_instancemethod(_FFPopSim.haploid_highd_unique_clones,None,haploid_highd)
haploid_highd.random_clone = new_instancemethod(_FFPopSim.haploid_highd_random_clone,None,haploid_highd)
haploid_highd.get_diversity_statistics = new_instancemethod(_FFPopSim.haploid_highd_get_diversity_statistics,None,haploid_highd)
haploid_highd.get_divergence_statistics = new_instancemethod(_FFPopSim.haploid_highd_get_divergence_statistics,None,haploid_highd)
haploid_highd.get_allele_frequency = new_instancemethod(_FFPopSim.haploid_highd_get_allele_frequency,None,haploid_highd)
haploid_highd.get_pair_frequency = new_instancemethod(_FFPopSim.haploid_highd_get_pair_frequency,None,haploid_highd)
haploid_highd.get_chi = new_instancemethod(_FFPopSim.haploid_highd_get_chi,None,haploid_highd)
haploid_highd._get_participation_ratio = new_instancemethod(_FFPopSim.haploid_highd__get_participation_ratio,None,haploid_highd)
haploid_highd.get_fitness = new_instancemethod(_FFPopSim.haploid_highd_get_fitness,None,haploid_highd)
haploid_highd.get_clone_size = new_instancemethod(_FFPopSim.haploid_highd_get_clone_size,None,haploid_highd)
haploid_highd.get_trait = new_instancemethod(_FFPopSim.haploid_highd_get_trait,None,haploid_highd)
haploid_highd.get_fitness_statistics = new_instancemethod(_FFPopSim.haploid_highd_get_fitness_statistics,None,haploid_highd)
haploid_highd.get_trait_statistics = new_instancemethod(_FFPopSim.haploid_highd_get_trait_statistics,None,haploid_highd)
haploid_highd.get_trait_covariance = new_instancemethod(_FFPopSim.haploid_highd_get_trait_covariance,None,haploid_highd)
haploid_highd._get_max_fitness = new_instancemethod(_FFPopSim.haploid_highd__get_max_fitness,None,haploid_highd)
haploid_highd._update_traits = new_instancemethod(_FFPopSim.haploid_highd__update_traits,None,haploid_highd)
haploid_highd._update_fitness = new_instancemethod(_FFPopSim.haploid_highd__update_fitness,None,haploid_highd)
haploid_highd.__str__ = new_instancemethod(_FFPopSim.haploid_highd___str__,None,haploid_highd)
haploid_highd.__repr__ = new_instancemethod(_FFPopSim.haploid_highd___repr__,None,haploid_highd)
haploid_highd._set_allele_frequencies = new_instancemethod(_FFPopSim.haploid_highd__set_allele_frequencies,None,haploid_highd)
haploid_highd._set_genotypes = new_instancemethod(_FFPopSim.haploid_highd__set_genotypes,None,haploid_highd)
haploid_highd._get_allele_frequencies = new_instancemethod(_FFPopSim.haploid_highd__get_allele_frequencies,None,haploid_highd)
haploid_highd._get_genotype = new_instancemethod(_FFPopSim.haploid_highd__get_genotype,None,haploid_highd)
haploid_highd._get_additive_trait = new_instancemethod(_FFPopSim.haploid_highd__get_additive_trait,None,haploid_highd)
haploid_highd.set_additive_trait = new_instancemethod(_FFPopSim.haploid_highd_set_additive_trait,None,haploid_highd)
haploid_highd.set_additive_fitness = new_instancemethod(_FFPopSim.haploid_highd_set_additive_fitness,None,haploid_highd)
haploid_highd._get_fitnesses = new_instancemethod(_FFPopSim.haploid_highd__get_fitnesses,None,haploid_highd)
haploid_highd._get_clone_sizes = new_instancemethod(_FFPopSim.haploid_highd__get_clone_sizes,None,haploid_highd)
haploid_highd.random_clones = new_instancemethod(_FFPopSim.haploid_highd_random_clones,None,haploid_highd)
haploid_highd_swigregister = _FFPopSim.haploid_highd_swigregister
haploid_highd_swigregister(haploid_highd)

HIVPOP_VERBOSE = _FFPopSim.HIVPOP_VERBOSE
HIVPOP_BADARG = _FFPopSim.HIVPOP_BADARG
NOTHING = _FFPopSim.NOTHING
HIVGENOME = _FFPopSim.HIVGENOME
ENV_START = _FFPopSim.ENV_START
ENV_END = _FFPopSim.ENV_END
class hivgene(object):
    """Structure for an HIV gene."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    start = _swig_property(_FFPopSim.hivgene_start_get, _FFPopSim.hivgene_start_set)
    end = _swig_property(_FFPopSim.hivgene_end_get, _FFPopSim.hivgene_end_set)
    def __init__(self, start_in=0, end_in=10000): 
        """Structure for an HIV gene."""
        _FFPopSim.hivgene_swiginit(self,_FFPopSim.new_hivgene(start_in, end_in))
    def __str__(self):
        """__str__(hivgene self) -> char const *"""
        return _FFPopSim.hivgene___str__(self)

    def __repr__(self):
        """__repr__(hivgene self) -> char const *"""
        return _FFPopSim.hivgene___repr__(self)

    __swig_destroy__ = _FFPopSim.delete_hivgene
hivgene.__str__ = new_instancemethod(_FFPopSim.hivgene___str__,None,hivgene)
hivgene.__repr__ = new_instancemethod(_FFPopSim.hivgene___repr__,None,hivgene)
hivgene_swigregister = _FFPopSim.hivgene_swigregister
hivgene_swigregister(hivgene)

class hivpopulation(haploid_highd):
    """
    Class for HIV population genetics (genome size = 10000).

    This class is the main object for simulating the evolution of HIV.
    The class offers a number of functions, but an example will explain the basic
    idea::

       #####################################
       #   EXAMPLE SCRIPT                  #
       #####################################
       import numpy as np
       import matplotlib.pyplot as plt
       import FFPopSim as h
       
       c = h.hivpopulation(2000)        # Create a population of 2000 individuals
       c.evolve(100)                    # Evolve (neutrally) for 100 generations
       c.plot_divergence_histogram()
       plt.show()
       #####################################

    **This class is a subclass of haploid_high and offers most of its methods.**
    In addition to the haploid_highd class, this class offers functions for reading
    fitness and drug resistance landscapes from a text file, and to save genomes as
    plain text or in compressed NumPy format.

    Moreover, there are two phenotypic traits, replication and resistance. Their
    relative importance for viral fitness is set by the ``treatment`` attribute::

       f[trait] = trait[0] + treatment * trait[1]

    By default, ``treatment`` is set to zero, to simulate non-treated patients.

    The gene structure of HIV is not modelled explicitely, except for a stub of
    1000 sites between position 7000 and 8000 to roughly model the _env_ gene.

    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, N=0, rng_seed=0, mutation_rate=3e-5, coinfection_rate=1e-2, crossover_rate=1e-3): 
        """
        Construct a HIV population with certain parameters.

        Parameters:
        - N     number of viral particles
        - rng_seed	seed for the random number generator. If this is 0, time(NULL)+getpid() is used.
        - mutation_rate	mutation rate in events / generation / site
        - coinfection_rate	probability of coinfection of the same cell by two viral particles in events / generation
        - crossover_rate	probability of template switching during coinfection in events / site

        Note: the genome length is 10000 (see HIVGENOME).

        """
        _FFPopSim.hivpopulation_swiginit(self,_FFPopSim.new_hivpopulation(N, rng_seed, mutation_rate, coinfection_rate, crossover_rate))
    __swig_destroy__ = _FFPopSim.delete_hivpopulation
    env = _swig_property(_FFPopSim.hivpopulation_env_get, _FFPopSim.hivpopulation_env_set)
    def _set_treatment(self, *args, **kwargs):
        """_set_treatment(hivpopulation self, double t)"""
        return _FFPopSim.hivpopulation__set_treatment(self, *args, **kwargs)

    def _get_treatment(self):
        """
        Treatment weight (between 0 and 1)

        .. note:: this variable controls how important is either of the two phenotypic
                  traits, replication and resistance. Their contribution to fitness is
                  always linear (in this implementation).

        """
        return _FFPopSim.hivpopulation__get_treatment(self)

    def read_replication_coefficients(self, *args, **kwargs):
        """read_replication_coefficients(hivpopulation self, istream & model) -> int"""
        return _FFPopSim.hivpopulation_read_replication_coefficients(self, *args, **kwargs)

    def read_resistance_coefficients(self, *args, **kwargs):
        """read_resistance_coefficients(hivpopulation self, istream & model) -> int"""
        return _FFPopSim.hivpopulation_read_resistance_coefficients(self, *args, **kwargs)

    def write_genotypes(self, *args, **kwargs):
        """
        Store random genotypes into a plain text file.

        Parameters:
           - filename: string with the name of the file to store the genotype into
           - sample_size: how many random genotypes to store
           - gt_label: common fasta label for the genotypes (e.g. 'HIV-sim')
           - start: if only a portion of the genome is to be stored, start from this position
           - length: store a chunk from ``start`` to this length

        """
        return _FFPopSim.hivpopulation_write_genotypes(self, *args, **kwargs)

    treatment = property(_get_treatment, _set_treatment)

    def write_genotypes_compressed(self, filename, sample_size, gt_label='', start=0, length=0):
        '''Store random genotypes into a compressed file.

        Parameters:
           - filename: string with the name of the file to store the genotype into
           - sample_size: how many random genotypes to store
           - gt_label: common fasta label for the genotypes (e.g. "HIV-sim")
           - start: if only a portion of the genome is to be stored, start from this position
           - length: store a chunk from ``start`` to this length

        The genotypes can be read using numpy.load.
        '''

        import numpy as np 
        L = self.number_of_loci
        if length <= 0:
            length = L - start
        d = {}
        for i in xrange(sample_size):
            rcl = self.random_clone()
            d['>'+str(i)+'_GT-'+gt_label+'_'+str(rcl)] = self.get_genotype(rcl,L)[start:start+length]
        np.savez_compressed(filename, **d)    

    def set_trait_landscape(self,
                            traitnumber=0,
                            lethal_fraction=0.05,
                            deleterious_fraction=0.8,
                            adaptive_fraction=0.01,
                            effect_size_lethal=0.8,
                            effect_size_deleterious=0.1,
                            effect_size_adaptive=0.01,
                            env_fraction=0.1,
                            effect_size_env=0.01,
                            number_epitopes=0,
                            epitope_strength=0.05,
                            number_valleys=0,
                            valley_strength=0.1,
                            ):
        '''Set HIV trait landscape according to some general parameters.

        Parameters:
           - lethal_fraction: fraction of lethal sites
           - deleterious_fraction: fraction of deleterious sites
           - adaptive_fraction: fraction of beneficial sites
           - effect_size_lethal: effect of lethal changes
           - effect_size_deleterious: average effect of deleterious changes
           - effect_size_adaptive: average effect of beneficial changes

           - env_fraction: fraction of beneficial sites in env
           - effect_size_env: average effect of beneficial changes in env
           - number_epitopes: number of (epistatic) epitopes
           - epitope_strength: average height of an epitope escape mutation
           - number_valleys: number of (epistatic) valleys
           - valley_strength: average depth of a valley

        .. note:: the effects of deleterious and beneficial sites are exponentially
                  distributed, i.e. most of them will still be almost neutral.
        
        .. note:: fractions refer to first and second positions only. For instance,
                  by default, 80% of first and second positions outside env are
                  deleterious.

        .. note:: the third positions are always neutral (synonymous).
        '''

        import numpy as np
        
        
        self.clear_trait(traitnumber)

        
        L = self.L
        aL = np.arange(L)

        
        
        
        
        
        
        onetwo_vector = (aL % 3) < 2
        random_numbers = np.random.random(L)
        adaptive_mutations = (random_numbers > (1 - adaptive_fraction)) & onetwo_vector
        lethal_mutations = (random_numbers < lethal_fraction) & onetwo_vector
        deleterious_mutations = ((random_numbers > lethal_fraction) & \
                                 (random_numbers < (lethal_fraction + deleterious_fraction)) & \
                                 (random_numbers < (1 - adaptive_fraction)) & \
                                 onetwo_vector)
        
        
        single_locus_effects=np.zeros(L)
        single_locus_effects[np.where(deleterious_mutations)] = -np.random.exponential(effect_size_deleterious, deleterious_mutations.sum())
        single_locus_effects[np.where(adaptive_mutations)] = np.random.exponential(effect_size_adaptive, adaptive_mutations.sum())
        single_locus_effects[np.where(lethal_mutations)] = -effect_size_lethal
        
        
        env_position = (aL >= self.env.start) & (aL < self.env.end)
        env_mutations = (random_numbers > (1 - env_fraction)) & onetwo_vector & env_position
        single_locus_effects[np.where(env_mutations)] = np.random.exponential(effect_size_env, env_mutations.sum())
            
        
        self.set_additive_trait(single_locus_effects, traitnumber)

        
        multi_locus_coefficients=[]
        def add_epitope(strength=0.2):
            '''Note: we are in the +-1 basis.'''
            loci = random.sample(range(9),2)
            loci.sort()
            depression = - 0.05
            f1 = depression*0.25
            f2 = depression*0.25
            f12 = depression*0.25 - strength*0.5
            return loci, f1,f2,f12
         
        def add_valley(depth=0.1, height=0.01):
            '''Note: we are in the +-1 basis.'''
            f1 = height*0.25
            f2 = height*0.25
            f12 = height*0.25 + depth*0.5
            return (f1,f2,f12)

        
        for vi in xrange(number_valleys):
            pos = np.random.random_integers(L/3-100)
            d = int(np.random.exponential(10) + 1)
            valley_str = np.random.exponential(valley_strength)
            if number_valleys:
                print 'valley:', pos*3, valley_str
            (f1,f2,f12)=add_valley(valley_str)
            single_locus_effects[pos*3+1]+=f1
            single_locus_effects[(pos+d)*3+1]+=f2
            multi_locus_coefficients.append([[pos*3+1, (pos+d)*3+1], f12])
        
        
        for ei in xrange(number_epitopes):
            pos = np.random.random_integers(L/3-10)
            epi_strength = np.random.exponential(epitope_strength)
            if number_epitopes:
                    print 'epitope', pos*3, epi_strength
            epi, f1,f2,f12=add_epitope(epi_strength)
            single_locus_effects[(pos+epi[0])*3+1]+=f1
            single_locus_effects[(pos+epi[1])*3+1]+=f2
            multi_locus_coefficients.append([[(pos+epi[0])*3+1, (pos+epi[1])*3+1], f12])

        for mlc in multi_locus_coefficients:
            self.add_trait_coefficient(mlc[1], np.asarray(mlc[0], int), traitnumber)
        self.update_traits()
        self.update_fitness()

    def get_additive_replication(self):
        '''The additive part of the replication lansdscape.

        Returns:
           - coefficients: array of additive replication coefficients

        .. warning:: the -/+ basis is used throughout the library.
                     If you are used to the 0/1 basis, keep in mind that
                     the interaction series-expansion is different.
        '''
        return self.get_additive_trait(0)


    def set_additive_replication(self, coefficients):
        '''Set the additive replication coefficients

        Parameters:
           - coefficients: array of additive replication coefficients

        .. warning:: the -/+ basis is used throughout the library.
                     If you are used to the 0/1 basis, keep in mind that
                     the interaction series-expansion is different.
        '''

        self.set_additive_trait(coefficients, 0)


    def get_additive_resistance(self):
        '''The additive part of the resistance lansdscape.

        Returns:
           - coefficients: array of additive drug resistance coefficients

        .. warning:: the -/+ basis is used throughout the library.
                     If you are used to the 0/1 basis, keep in mind that
                     the interaction series-expansion is different.
        '''
        return self.get_additive_trait(1)


    def set_additive_resistance(self, coefficients):
        '''Set the additive drug resistance coefficients

        Parameters:
           - coefficients: array of additive drug resistance coefficients

        .. warning:: the -/+ basis is used throughout the library.
                     If you are used to the 0/1 basis, keep in mind that
                     the interaction series-expansion is different.
        '''

        self.set_additive_trait(coefficients, 1)



    def set_replication_landscape(self,
                            lethal_fraction=0.05,
                            deleterious_fraction=0.8,
                            adaptive_fraction=0.01,
                            effect_size_lethal=0.8,
                            effect_size_deleterious=0.1,
                            effect_size_adaptive=0.01,
                            env_fraction=0.1,
                            effect_size_env=0.01,
                            number_epitopes=0,
                            epitope_strength=0.05,
                            number_valleys=0,
                            valley_strength=0.1,
                            ):
        '''Set the phenotypic landscape for the replication capacity of HIV.
        
        Parameters:
           - lethal_fraction: fraction of lethal sites
           - deleterious_fraction: fraction of deleterious sites
           - adaptive_fraction: fraction of beneficial sites
           - effect_size_lethal: effect of lethal changes
           - effect_size_deleterious: average effect of deleterious changes
           - effect_size_adaptive: average effect of beneficial changes

           - env_fraction: fraction of beneficial sites in env
           - effect_size_env: average effect of beneficial changes in env
           - number_epitopes: number of (epistatic) epitopes
           - epitope_strength: average height of an epitope escape mutation
           - number_valleys: number of (epistatic) valleys
           - valley_strength: average depth of a valley

        .. note:: the effects of deleterious and beneficial sites are exponentially
                  distributed, i.e. most of them will still be almost neutral.
        
        .. note:: fractions refer to first and second positions only. For instance,
                  by default, 80% of first and second positions outside env are
                  deleterious.

        .. note:: the third positions are always neutral (synonymous).
        '''

        self.set_trait_landscape(traitnumber=0,
                            lethal_fraction=lethal_fraction,
                            deleterious_fraction=deleterious_fraction,
                            adaptive_fraction=adaptive_fraction,
                            effect_size_lethal=effect_size_lethal,
                            effect_size_deleterious=effect_size_deleterious,
                            effect_size_adaptive=effect_size_adaptive,
                            env_fraction=env_fraction,
                            effect_size_env=effect_size_env,
                            number_epitopes=number_epitopes,
                            epitope_strength=epitope_strength,
                            number_valleys=number_valleys,
                            valley_strength=valley_strength)


    def set_resistance_landscape(self,
                            lethal_fraction=0.05,
                            deleterious_fraction=0.8,
                            adaptive_fraction=0.01,
                            effect_size_lethal=0.8,
                            effect_size_deleterious=0.1,
                            effect_size_adaptive=0.01,
                            env_fraction=0.1,
                            effect_size_env=0.01,
                            number_epitopes=0,
                            epitope_strength=0.05,
                            number_valleys=0,
                            valley_strength=0.1,
                            ):
        '''Set the phenotypic landscape for the drug resistance of HIV.
        
        Parameters:
           - lethal_fraction: fraction of lethal sites
           - deleterious_fraction: fraction of deleterious sites
           - adaptive_fraction: fraction of beneficial sites
           - effect_size_lethal: effect of lethal changes
           - effect_size_deleterious: average effect of deleterious changes
           - effect_size_adaptive: average effect of beneficial changes

           - env_fraction: fraction of beneficial sites in env
           - effect_size_env: average effect of beneficial changes in env
           - number_epitopes: number of (epistatic) epitopes
           - epitope_strength: average height of an epitope escape mutation
           - number_valleys: number of (epistatic) valleys
           - valley_strength: average depth of a valley

        .. note:: the effects of deleterious and beneficial sites are exponentially
                  distributed, i.e. most of them will still be almost neutral.
        
        .. note:: fractions refer to first and second positions only. For instance,
                  by default, 80% of first and second positions outside env are
                  deleterious.

        .. note:: the third positions are always neutral (synonymous).
        '''

        self.set_trait_landscape(traitnumber=1,
                            lethal_fraction=lethal_fraction,
                            deleterious_fraction=deleterious_fraction,
                            adaptive_fraction=adaptive_fraction,
                            effect_size_lethal=effect_size_lethal,
                            effect_size_deleterious=effect_size_deleterious,
                            effect_size_adaptive=effect_size_adaptive,
                            env_fraction=env_fraction,
                            effect_size_env=effect_size_env,
                            number_epitopes=number_epitopes,
                            epitope_strength=epitope_strength,
                            number_valleys=number_valleys,
                            valley_strength=valley_strength)



hivpopulation._set_treatment = new_instancemethod(_FFPopSim.hivpopulation__set_treatment,None,hivpopulation)
hivpopulation._get_treatment = new_instancemethod(_FFPopSim.hivpopulation__get_treatment,None,hivpopulation)
hivpopulation.read_replication_coefficients = new_instancemethod(_FFPopSim.hivpopulation_read_replication_coefficients,None,hivpopulation)
hivpopulation.read_resistance_coefficients = new_instancemethod(_FFPopSim.hivpopulation_read_resistance_coefficients,None,hivpopulation)
hivpopulation.write_genotypes = new_instancemethod(_FFPopSim.hivpopulation_write_genotypes,None,hivpopulation)
hivpopulation_swigregister = _FFPopSim.hivpopulation_swigregister
hivpopulation_swigregister(hivpopulation)



